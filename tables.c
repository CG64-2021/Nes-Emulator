#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "bus.h"
#include "ppu.h"
#include "cpu.h"
#include "tables.h"

//Colors lookup table, to colorise pixels in CHR format
color_t colors[64] = {
	{0x80, 0x80, 0x80}, {0x00, 0x3D, 0xA6}, {0x00, 0x12, 0xB0}, {0x44, 0x00, 0x96}, {0xA1, 0x00, 0x5E},
	{0xC7, 0x00, 0x28}, {0xBA, 0x06, 0x00}, {0x8C, 0x17, 0x00}, {0x5C, 0x2F, 0x00}, {0x10, 0x45, 0x00},
	{0x05, 0x4A, 0x00}, {0x00, 0x47, 0x2E}, {0x00, 0x41, 0x66}, {0x00, 0x00, 0x00}, {0x05, 0x05, 0x05},
	{0x05, 0x05, 0x05}, {0xC7, 0xC7, 0xC7}, {0x00, 0x77, 0xFF}, {0x21, 0x55, 0xFF}, {0x82, 0x37, 0xFA},
	{0xEB, 0x2F, 0xB5}, {0xFF, 0x29, 0x50}, {0xFF, 0x22, 0x00}, {0xD6, 0x32, 0x00}, {0xC4, 0x62, 0x00},
	{0x35, 0x80, 0x00}, {0x05, 0x8F, 0x00}, {0x00, 0x8A, 0x55}, {0x00, 0x99, 0xCC}, {0x21, 0x21, 0x21},
	{0x09, 0x09, 0x09}, {0x09, 0x09, 0x09}, {0xFF, 0xFF, 0xFF}, {0x0F, 0xD7, 0xFF}, {0x69, 0xA2, 0xFF},
	{0xD4, 0x80, 0xFF}, {0xFF, 0x45, 0xF3}, {0xFF, 0x61, 0x8B}, {0xFF, 0x88, 0x33}, {0xFF, 0x9C, 0x12},
	{0xFA, 0xBC, 0x20}, {0x9F, 0xE3, 0x0E}, {0x2B, 0xF0, 0x35}, {0x0C, 0xF0, 0xA4}, {0x05, 0xFB, 0xFF},
	{0x5E, 0x5E, 0x5E}, {0x0D, 0x0D, 0x0D}, {0x0D, 0x0D, 0x0D}, {0xFF, 0xFF, 0xFF}, {0xA6, 0xFC, 0xFF},
	{0xB3, 0xEC, 0xFF}, {0xDA, 0xAB, 0xEB}, {0xFF, 0xA8, 0xF9}, {0xFF, 0xAB, 0xB3}, {0xFF, 0xD2, 0xB0},
	{0xFF, 0xEF, 0xA6}, {0xFF, 0xF7, 0x9C}, {0xD7, 0xE8, 0x95}, {0xA6, 0xED, 0xAF}, {0xA2, 0xF2, 0xDA},
	{0x99, 0xFF, 0xFC}, {0xDD, 0xDD, 0xDD}, {0x11, 0x11, 0x11}, {0x11, 0x11, 0x11}
};

//Opcodes lookup table, generated by chatGPT (thx technology)
opcode_t opcode_lookup_table[256] = {
    { "BRK", IMP, 7 }, // 0x00
    { "ORA", IZX, 6 }, // 0x01
    { "STP", IMP, 2 }, // 0x02 (unofficial)
    { "SLO", IZX, 8 }, // 0x03 (unofficial)
    { "NOP", ZP0, 3 }, // 0x04 (unofficial)
    { "ORA", ZP0, 3 }, // 0x05
    { "ASL", ZP0, 5 }, // 0x06
    { "SLO", ZP0, 5 }, // 0x07 (unofficial)
    { "PHP", IMP, 3 }, // 0x08
    { "ORA", IMM, 2 }, // 0x09
    { "ASL", ACC, 2 }, // 0x0A
    { "ANC", IMM, 2 }, // 0x0B (unofficial)
    { "NOP", ABS, 4 }, // 0x0C (unofficial)
    { "ORA", ABS, 4 }, // 0x0D
    { "ASL", ABS, 6 }, // 0x0E
    { "SLO", ABS, 6 }, // 0x0F (unofficial)
    { "BPL", REL, 2 }, // 0x10
    { "ORA", IZY, 5 }, // 0x11 (unofficial)
    { "STP", IMP, 2 }, // 0x12 (unofficial)
    { "SLO", IZY, 8 }, // 0x13 (unofficial)
    { "NOP", ZPX, 4 }, // 0x14 (unofficial)
    { "ORA", ZPX, 4 }, // 0x15 (unofficial)
    { "ASL", ZPX, 6 }, // 0x16 (unofficial)
    { "SLO", ZPX, 6 }, // 0x17 (unofficial)
    { "CLC", IMP, 2 }, // 0x18
    { "ORA", ABY, 4 }, // 0x19 (unofficial)
    { "NOP", IMP, 2 }, // 0x1A (unofficial)
    { "SLO", ABY, 7 }, // 0x1B (unofficial)
    { "NOP", ABX, 4 }, // 0x1C (unofficial)
    { "ORA", ABX, 4 }, // 0x1D (unofficial)
    { "ASL", ABX, 7 }, // 0x1E (unofficial)
    { "SLO", ABX, 7 }, // 0x1F (unofficial)
    { "JSR", ABS, 6 }, // 0x20
    { "AND", IZX, 6 }, // 0x21 (unofficial)
    { "STP", IMP, 2 }, // 0x22 (unofficial)
    { "RLA", IZX, 8 }, // 0x23 (unofficial)
    { "BIT", ZP0, 3 }, // 0x24
    { "AND", ZP0, 3 }, // 0x25
    { "ROL", ZP0, 5 }, // 0x26
    { "RLA", ZP0, 5 }, // 0x27 (unofficial)
    { "PLP", IMP, 4 }, // 0x28
    { "AND", IMM, 2 }, // 0x29
    { "ROL", ACC, 2 }, // 0x2A
    { "ANC", IMM, 2 }, // 0x2B (unofficial)
    { "BIT", ABS, 4 }, // 0x2C
    { "AND", ABS, 4 }, // 0x2D
    { "ROL", ABS, 6 }, // 0x2E
    { "RLA", ABS, 6 }, // 0x2F (unofficial)
    { "BMI", REL, 2 }, // 0x30
    { "AND", IZY, 5 }, // 0x31 (unofficial)
    { "STP", IMP, 2 }, // 0x32 (unofficial)
    { "RLA", IZY, 8 }, // 0x33 (unofficial)
    { "NOP", ZPX, 4 }, // 0x34 (unofficial)
    { "AND", ZPX, 4 }, // 0x35 (unofficial)
    { "ROL", ZPX, 6 }, // 0x36 (unofficial)
    { "RLA", ZPX, 6 }, // 0x37 (unofficial)
    { "SEC", IMP, 2 }, // 0x38
    { "AND", ABY, 4 }, // 0x39 (unofficial)
    { "NOP", IMP, 2 }, // 0x3A (unofficial)
    { "RLA", ABY, 7 }, // 0x3B (unofficial)
    { "NOP", ABX, 4 }, // 0x3C (unofficial)
    { "AND", ABX, 4 }, // 0x3D (unofficial)
    { "ROL", ABX, 7 }, // 0x3E (unofficial)
    { "RLA", ABX, 7 }, // 0x3F (unofficial)
    { "RTI", IMP, 6 }, // 0x40
    { "EOR", IZX, 6 }, // 0x41 (unofficial)
    { "STP", IMP, 2}, // 0x42 (unofficial)
    { "SRE", IZX, 8 }, // 0x43 (unofficial)
    { "NOP", ZP0, 3 }, // 0x44 (unofficial)
    { "EOR", ZP0, 3 }, // 0x45 (unofficial)
    { "LSR", ZP0, 5 }, // 0x46 (unofficial)
    { "SRE", ZP0, 5 }, // 0x47 (unofficial)
    { "PHA", IMP, 3 }, // 0x48
    { "EOR", IMM, 2 }, // 0x49
    { "LSR", ACC, 2 }, // 0x4A
    { "ALR", IMM, 2 }, // 0x4B (unofficial)
    { "JMP", ABS, 3 }, // 0x4C
    { "EOR", ABS, 4 }, // 0x4D
    { "LSR", ABS, 6 }, // 0x4E (unofficial)
    { "SRE", ABS, 6 }, // 0x4F (unofficial)
    { "BVC", REL, 2 }, // 0x50
    { "EOR", IZY, 5 }, // 0x51 (unofficial)
    { "STP", IMP, 2 }, // 0x52 (unofficial)
    { "SRE", IZY, 8 }, // 0x53 (unofficial)
    { "NOP", ZPX, 4 }, // 0x54 (unofficial)
    { "EOR", ZPX, 4 }, // 0x55 (unofficial)
    { "LSR", ZPX, 6 }, // 0x56 (unofficial)
    { "SRE", ZPX, 6 }, // 0x57 (unofficial)
    { "CLI", IMP, 2 }, // 0x58
    { "EOR", ABY, 4 }, // 0x59 (unofficial)
    { "NOP", IMP, 2 }, // 0x5A (unofficial)
    { "SRE", ABY, 7 }, // 0x5B (unofficial)
    { "NOP", ABX, 4 }, // 0x5C (unofficial)
    { "EOR", ABX, 4 }, // 0x5D (unofficial)
    { "LSR", ABX, 7 }, // 0x5E (unofficial)
    { "SRE", ABX, 7 }, // 0x5F (unofficial)
    { "RTS", IMP, 6 }, // 0x60
    { "ADC", IZX, 6 }, // 0x61 (unofficial)
    { "STP", IMP, 2 }, // 0x62 (unofficial)
    { "RRA", IZX, 8 }, // 0x63 (unofficial)
    { "NOP", ZP0, 3 }, // 0x64 (unofficial)
    { "ADC", ZP0, 3 }, // 0x65 (unofficial)
    { "ROR", ZP0, 5 }, // 0x66 (unofficial)
    { "RRA", ZP0, 5 }, // 0x67 (unofficial)
    { "PLA", IMP,3 }, // 0x68
    { "ADC", IMM, 2 }, // 0x69
    { "ROR", ACC, 2 }, // 0x6A
    { "ARR", IMM, 2 }, // 0x6B (unofficial)
    { "JMP", IND, 5 }, // 0x6C
    { "ADC", ABS, 4 }, // 0x6D
    { "ROR", ABS, 6 }, // 0x6E (unofficial)
    { "RRA", ABS, 6 }, // 0x6F (unofficial)
    { "BVS", REL, 2 }, // 0x70
    { "ADC", IZY, 5 }, // 0x71 (unofficial)
    { "STP", IMP, 2 }, // 0x72 (unofficial)
    { "RRA", IZY, 8 }, // 0x73 (unofficial)
    { "NOP", ZPX, 4 }, // 0x74 (unofficial)
    { "ADC", ZPX, 4 }, // 0x75 (unofficial)
    { "ROR", ZPX, 6 }, // 0x76 (unofficial)
    { "RRA", ZPX, 6 }, // 0x77 (unofficial)
    { "SEI", IMP, 2 }, // 0x78
    { "ADC", ABY, 4 }, // 0x79 (unofficial)
    { "NOP", IMP, 2 }, // 0x7A (unofficial)
    { "RRA", ABY, 7 }, // 0x7B (unofficial)
    { "NOP", ABX, 4 }, // 0x7C (unofficial)
    { "ADC", ABX, 4 }, // 0x7D (unofficial)
    { "ROR", ABX, 7 }, // 0x7E (unofficial)
    { "RRA", ABX, 7 }, // 0x7F (unofficial)
    { "NOP", IMM, 2 }, // 0x80 (unofficial)
    { "STA", IZX, 6 }, // 0x81 (unofficial)
    { "NOP", IMM, 2 }, // 0x82 (unofficial)
    { "SAX", IZX, 6 }, // 0x83 (unofficial)
    { "STY", ZP0, 3 }, // 0x84
    { "STA", ZP0, 3 }, // 0x85
    { "STX", ZP0, 3 }, // 0x86
    { "SAX", ZP0, 3 }, // 0x87 (unofficial)
    { "DEY", IMP, 2 }, // 0x88
    { "NOP", IMM, 2 }, // 0x89 (unofficial)
    { "TXA", IMP, 2 }, // 0x8A
    { "ANE", IMM, 2 }, // 0x8B (unofficial)
    { "STY", ABS, 4 }, // 0x8C
    { "STA", ABS, 4 }, // 0x8D
    { "STX", ABS, 4 }, // 0x8E
    { "SAX", ABS, 4 }, // 0x8F (unofficial)
    { "BCC", REL, 2 }, // 0x90
    { "STA", IZY, 6 }, // 0x91 (unofficial)
    { "STP", IMP, 2 }, // 0x92 (unofficial)
    { "SHA", IZY, 6 }, // 0x93 (unofficial)
    { "STY", ZPX, 4 }, // 0x94 (unofficial)
    { "STA", ZPX, 4 }, // 0x95 (unofficial)
    { "STX", ZPY, 4 }, // 0x96 (unofficial)
    { "SAX", ZPY, 4 }, // 0x97 (unofficial)
    { "TYA", IMP, 2 }, // 0x98
    { "STA", ABY, 5 }, // 0x99 (unofficial)
    { "TXS", IMP, 2 }, // 0x9A
    { "SHS", ABY, 5 }, // 0x9B (unofficial)
    { "SHY", ABX, 5 }, // 0x9C (unofficial)
    { "STA", ABX, 5 }, // 0x9D (unofficial)
    { "SHX", ABY, 5 }, // 0x9E (unofficial)
    { "SHA", ABY, 5 }, // 0x9F (unofficial)
    { "LDY", IMM, 2 }, // 0xA0
    { "LDA", IZX, 6 }, // 0xA1 (unofficial)
    { "LDX", IMM, 2 }, // 0xA2
    { "LAX", IZX, 6 }, // 0xA3 (unofficial)
    { "LDY", ZP0, 3 }, // 0xA4
    { "LDA", ZP0, 3 }, // 0xA5
    { "LDX", ZP0, 3 }, // 0xA6
    { "LAX", ZP0, 3 }, // 0xA7 (unofficial)
    { "TAY", IMP, 2 }, // 0xA8
    { "LDA", IMM, 2 }, // 0xA9
    { "TAX", IMP, 2 }, // 0xAA
    { "LAX", IMM, 2 }, // 0xAB (unofficial)
    { "LDY", ABS, 4 }, // 0xAC
    { "LDA", ABS, 4 }, // 0xAD
    { "LDX", ABS, 4 }, // 0xAE
    { "LAX", ABS, 4 }, // 0xAF (unofficial)
    { "BCS", REL, 2 }, // 0xB0
    { "LDA", IZY, 5 }, // 0xB1 (unofficial)
    { "STP", IMP, 2 }, // 0xB2 (unofficial)
    { "LAX", IZY, 5 }, // 0xB3 (unofficial)
    { "LDY", ZPX, 4 }, // 0xB4 (unofficial)
    { "LDA", ZPX, 4 }, // 0xB5 (unofficial)
    { "LDX", ZPY, 4 }, // 0xB6 (unofficial)
    { "LAX", ZPY, 4}, // 0xB7 (unofficial)
    { "CLV", IMP, 2 }, // 0xB8
    { "LDA", ABY, 4 }, // 0xB9 (unofficial)
    { "TSX", IMP, 2 }, // 0xBA
    { "LAS", ABY, 4 }, // 0xBB (unofficial)
    { "LDY", ABX, 4 }, // 0xBC (unofficial)
    { "LDA", ABX, 4 }, // 0xBD (unofficial)
    { "LDX", ABY, 4 }, // 0xBE (unofficial)
    { "LAX", ABY, 4 }, // 0xBF (unofficial)
    { "CPY", IMM, 2 }, // 0xC0
    { "CMP", IZX, 6 }, // 0xC1 (unofficial)
    { "NOP", IMM, 2 }, // 0xC2 (unofficial)
    { "DCP", IZX, 8 }, // 0xC3 (unofficial)
    { "CPY", ZP0, 3 }, // 0xC4
    { "CMP", ZP0, 3 }, // 0xC5
    { "DEC", ZP0, 5 }, // 0xC6
    { "DCP", ZP0, 5 }, // 0xC7 (unofficial)
    { "INY", IMP, 2 }, // 0xC8
    { "CMP", IMM, 2 }, // 0xC9
    { "DEX", IMP, 2 }, // 0xCA
    { "AXS", IMM, 2 }, // 0xCB (unofficial)
    { "CPY", ABS, 4 }, // 0xCC
    { "CMP", ABS, 4 }, // 0xCD
    { "DEC", ABS, 6 }, // 0xCE
    { "DCP", ABS, 6 }, // 0xCF (unofficial)
    { "BNE", REL, 2 }, // 0xD0
    { "CMP", IZY, 5 }, // 0xD1 (unofficial)
    { "STP", IMP, 2 }, // 0xD2 (unofficial)
    { "DCP", IZY, 8 }, // 0xD3 (unofficial)
    { "NOP", ZPX, 4 }, // 0xD4 (unofficial)
    { "CMP", ZPX, 4 }, // 0xD5 (unofficial)
    { "DEC", ZPX, 6 }, // 0xD6 (unofficial)
    { "DCP", ZPX, 6 }, // 0xD7 (unofficial)
    { "CLD", IMP, 2 }, // 0xD8
    { "CMP", ABY, 4 }, // 0xD9 (unofficial)
    { "NOP", IMP, 2 }, // 0xDA (unofficial)
    { "DCP", ABY, 7 }, // 0xDB (unofficial)
    { "NOP", ABX, 4 }, // 0xDC (unofficial)
    { "CMP", ABX, 4 }, // 0xDD (unofficial)
    { "DEC", ABX, 7 }, // 0xDE (unofficial)
    { "DCP", ABX, 7 }, // 0xDF (unofficial)
    { "CPX", IMM, 2 }, // 0xE0
    { "SBC", IZX, 6 }, // 0xE1 (unofficial)
    { "NOP", IMM, 2 }, // 0xE2 (unofficial)
    { "ISC", IZX, 8 }, // 0xE3 (unofficial)
    { "CPX", ZP0, 3 }, // 0xE4
    { "SBC", ZP0, 3 }, // 0xE5
    { "INC", ZP0, 5 }, // 0xE6
    { "ISC", ZP0, 5 }, // 0xE7 (unofficial)
    { "INX", IMP, 2 }, // 0xE8
    { "SBC", IMM, 2 }, // 0xE9
    { "NOP", IMP, 2 }, // 0xEA
    { "SBC", IMM, 2 }, // 0xEB (unofficial)
    { "CPX", ABS, 4 }, // 0xEC
    { "SBC", ABS, 4 }, // 0xED
    { "INC", ABS, 6 }, // 0xEE
    { "ISC", ABS, 6 }, // 0xEF (unofficial)
    { "BEQ", REL, 2 }, // 0xF0
    { "SBC", IZY, 5 }, // 0xF1 (unofficial)
    { "STP", IMP, 2 }, // 0xF2 (unofficial)
    { "ISC", IZY, 8 }, // 0xF3 (unofficial)
    { "NOP", ZPX, 4 }, // 0xF4 (unofficial)
    { "SBC", ZPX, 4 }, // 0xF5 (unofficial)
    { "INC", ZPX, 6 }, // 0xF6 (unofficial)
    { "ISC", ZPX, 6 }, // 0xF7 (unofficial)
    { "SED", IMP, 2 }, // 0xF8
    { "SBC", ABY, 4 }, // 0xF9 (unofficial)
    { "NOP", IMP, 2 }, // 0xFA (unofficial)
    { "ISC", ABY, 7 }, // 0xFB (unofficial)
    { "NOP", ABX, 4 }, // 0xFC (unofficial)
    { "SBC", ABX, 4 }, // 0xFD (unofficial)
    { "INC", ABX, 7 }, // 0xFE (unofficial)
    { "ISC", ABX, 7 } // 0xFF (unofficial)
};

//Instruction functions
void BRK(cpu_t* cpu)
{
	cpu->status |= B;
}

void LDA(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_a = (uint8_t)value;
	if (!cpu->register_a) cpu->status |= Z;
	if (cpu->register_a & N) cpu->status |= N;
}

void LDX(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_x = (uint8_t)value;
	if (!cpu->register_x) cpu->status |= Z;
	if (cpu->register_x & N) cpu->status |= N;
}

void LDY(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_y = (uint8_t)value;
	if (!cpu->register_y) cpu->status |= Z;
	if (cpu->register_y & N) cpu->status |= N;
}

void STA(cpu_t* cpu, uint16_t value)
{
	mem_write(cpu->bus, cpu->register_a, value);
}

void STX(cpu_t* cpu, uint16_t value)
{
	mem_write(cpu->bus, cpu->register_x, value);
}

void STY(cpu_t* cpu, uint16_t value)
{
	mem_write(cpu->bus, cpu->register_y, value);
}

void TAX(cpu_t* cpu)
{
	cpu->register_x = cpu->register_a;
	cpu->status = !cpu->register_x ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_x&N)? cpu->status|N : cpu->status;
}

void TAY(cpu_t* cpu)
{
	cpu->register_y = cpu->register_a;
	cpu->status = !cpu->register_y ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_y&N)? cpu->status|N : cpu->status;
}

void TSX(cpu_t* cpu)
{
	uint16_t addr = 0x0100+cpu->stack_pointer;
	uint8_t val = mem_read(cpu->bus, addr);
	cpu->register_x = val;
	cpu->status = !cpu->register_x ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_x&N)? cpu->status|N : cpu->status;
}

void TXA(cpu_t* cpu)
{
	cpu->register_a = cpu->register_x;
	cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_a&N)? cpu->status|N : cpu->status;
}

void TYA(cpu_t* cpu)
{
	cpu->register_a = cpu->register_y;
	cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_a&N)? cpu->status|N : cpu->status;
}

void TXS(cpu_t* cpu)
{
	uint16_t addr = 0x0100+cpu->stack_pointer;
	mem_write(cpu->bus, cpu->register_x, addr);
}

void ADC(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_a += (uint8_t)value;
	if (cpu->register_a & N) {cpu->status |= C; cpu->status |= N;} //Set carry and negative flag if bit 7 is set
	if (cpu->register_a > 0x7F) cpu->status |= V; //Set overflow flag if a number is greater than 127
}

void SBC(cpu_t* cpu, uint16_t value)
{
	uint8_t res;
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_a -= (uint8_t)value;
	if (cpu->register_a & N) {cpu->status &= ~C; cpu->status |= N;} //Set carry and negative flag if bit 7 is set
	if (cpu->register_a > 0x7F) cpu->status |= V; //Set overflow flag if a number is greater than 127
}

void ASL(cpu_t* cpu, uint16_t value)
{
	uint8_t val = 0;
	if (cpu->opcode.addr_mode != ACC)
	{
		val = mem_read(cpu->bus, value);
	} else cpu->program_counter++;
	cpu->status = val!=0 ? cpu->status|(C&(val&0x80)) : cpu->status|(C&(value&0x80)); //Set carry bit if old MSB is 1
	if (val!=0)
	{
		val = (val << 1);
		cpu->status = !val ? cpu->status|Z : cpu->status; //Set Zero flag if result is 0
		cpu->status = (val&N) ? cpu->status|N : cpu->status; //Set Negative flag if MSB is 1
		cpu->register_a = val;
		mem_write(cpu->bus, val, value);
		return;
	}
	val = (uint8_t)value;
	val = (val << 1);
	cpu->status = !val ? cpu->status|Z : cpu->status; //Set Zero flag if result is 0
	cpu->status = (val&N) ? cpu->status|N : cpu->status; //Set Negative flag if MSB is 1
	cpu->register_a = val;
	
}

void LSR(cpu_t* cpu, uint16_t value)
{
	uint8_t val = 0;
	if (cpu->opcode.addr_mode != ACC)
	{
		val = mem_read(cpu->bus, value);
	} else cpu->program_counter++;
	cpu->status = val!=0 ? cpu->status|(C&(val&0x1)) : cpu->status|(C&(value&0x1)); //Set carry bit if old LSB is 1
	if (val!=0)
	{
		val = (val >> 1);
		cpu->status = !val ? cpu->status|Z : cpu->status; //Set Zero flag if result is 0
		cpu->status = (val&N) ? cpu->status|N : cpu->status; //Set Negative flag if MSB is 1
		cpu->register_a = val;
		mem_write(cpu->bus, val, value);
		return;
	}
	val = (uint8_t)value;
	val = (val >> 1);
	cpu->status = !val ? cpu->status|Z : cpu->status; //Set Zero flag if result is 0
	cpu->status = (val&N) ? cpu->status|N : cpu->status; //Set Negative flag if MSB is 1
	cpu->register_a = val;
}

void AND(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_a &= (uint8_t)value;
	cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_a&N) ? cpu->status|N : cpu->status;
}

void ORA(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_a |= (uint8_t)value;
	cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_a&N) ? cpu->status|N : cpu->status;
}

void EOR(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	cpu->register_a ^= (uint8_t)value;
	cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_a&N) ? cpu->status|N : cpu->status;
}

void PHA(cpu_t* cpu)
{
	uint16_t addr = 0x0100+cpu->stack_pointer;
	mem_write(cpu->bus, cpu->register_a, addr);
	cpu->stack_pointer--;
}

void PHP(cpu_t* cpu)
{
	uint16_t addr = 0x0100+cpu->stack_pointer;
	mem_write(cpu->bus, cpu->register_a, addr);
	cpu->stack_pointer--;
}

void PLA(cpu_t* cpu)
{
	uint16_t addr = 0x0100+cpu->stack_pointer;
	cpu->register_a = mem_read(cpu->bus, addr);
	cpu->stack_pointer++;
	cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_a&N) ? cpu->status|N : cpu->status;
}

void PLP(cpu_t* cpu)
{
	uint16_t addr = 0x0100+cpu->stack_pointer;
	cpu->status = mem_read(cpu->bus, addr);
	cpu->stack_pointer++;
}

void ROL(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode == ACC)
	{
		cpu->status = (cpu->register_a&0x80) ? cpu->status|C : cpu->status;
		cpu->register_a = cpu->register_a << 1;
		cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
		cpu->status = (cpu->register_a&N) ? cpu->status|N : cpu->status;
		return;
	}
	uint8_t val = mem_read(cpu->bus, value);
	cpu->status = (val&0x80) ? cpu->status|C : cpu->status;
	val = val << 1;
	mem_write(cpu->bus, val, value);
	//cpu->status = !val ? cpu->status|Z : cpu->status;
	cpu->status = (val&N) ? cpu->status|N : cpu->status;
}

void ROR(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode == ACC)
	{
		cpu->status = (cpu->register_a&0x1) ? cpu->status|C : cpu->status;
		cpu->register_a = cpu->register_a << 1;
		cpu->status = !cpu->register_a ? cpu->status|Z : cpu->status;
		cpu->status = (cpu->register_a&N) ? cpu->status|N : cpu->status;
		return;
	}
	uint8_t val = mem_read(cpu->bus, value);
	cpu->status = (val&0x1) ? cpu->status|C : cpu->status;
	val = val >> 1;
	mem_write(cpu->bus, val, value);
	//cpu->status = !val ? cpu->status|Z : cpu->status;
	cpu->status = (val&N) ? cpu->status|N : cpu->status;
}

void BIT(cpu_t* cpu, uint16_t value)
{
	uint8_t val = mem_read(cpu->bus, value);
	uint8_t res = cpu->register_a&val;
	
	cpu->status = !res ? cpu->status|Z : cpu->status;
	cpu->status = (res&V) ? cpu->status|V : cpu->status;
	cpu->status = (res&N) ? cpu->status|N : cpu->status;
}

void BMI(cpu_t* cpu, uint16_t value)
{
	if (!cpu->status&N)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BCC(cpu_t* cpu, uint16_t value)
{
	if (cpu->status&C)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BCS(cpu_t* cpu, uint16_t value)
{
	if (!cpu->status&C)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BEQ(cpu_t* cpu, uint16_t value)
{
	if (!cpu->status&Z)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BNE(cpu_t* cpu, uint16_t value)
{
	if (cpu->status&Z)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BPL(cpu_t* cpu, uint16_t value)
{
	if (cpu->status&N)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BVC(cpu_t* cpu, uint16_t value)
{
	if (cpu->status&V)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void BVS(cpu_t* cpu, uint16_t value)
{
	if (!cpu->status&V)
	{
		cpu->program_counter++;
		return;
	}
	uint16_t old_page = (cpu->program_counter&0xFF00);
	int8_t val = (int8_t)mem_read(cpu->bus, cpu->program_counter);
	cpu->program_counter += val;
	if ((cpu->program_counter&0xFF00) != old_page) cpu->clock++;
	cpu->clock++;
}

void CLC(cpu_t* cpu)
{
	cpu->status &= ~C;
}

void CLD(cpu_t* cpu)
{
	cpu->status &= ~D;
}

void CLI(cpu_t* cpu)
{
	cpu->status &= ~I;
}

void CLV(cpu_t* cpu)
{
	cpu->status &= ~V;
}

void SEC(cpu_t* cpu)
{
	cpu->status |= C;
}

void SED(cpu_t* cpu)
{
	cpu->status |= D;
}

void SEI(cpu_t* cpu)
{
	cpu->status |= I;
}

void CMP(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	uint8_t res = cpu->register_a-(uint8_t)value;
	cpu->status = !res ? cpu->status|Z : cpu->status;
	cpu->status = res>=0? cpu->status|C : cpu->status;
	cpu->status = (res&N)? cpu->status|N : cpu->status;
}

void CPX(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	uint8_t res = cpu->register_x-(uint8_t)value;
	cpu->status = !res ? cpu->status|Z : cpu->status;
	cpu->status = res>=0? cpu->status|C : cpu->status;
	cpu->status = (res&N)? cpu->status|N : cpu->status;
}

void CPY(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode != IMM)
	{
		uint8_t val = mem_read(cpu->bus, value);
		value = val;
	} else cpu->program_counter++;
	uint8_t res = cpu->register_y-(uint8_t)value;
	cpu->status = !res ? cpu->status|Z : cpu->status;
	cpu->status = res>=0? cpu->status|C : cpu->status;
	cpu->status = (res&N)? cpu->status|N : cpu->status;
}

void DEC(cpu_t* cpu, uint16_t value)
{
	uint8_t val = mem_read(cpu->bus, value);
	val--;
	mem_write(cpu->bus, val, value);
	cpu->status = !val ? cpu->status|Z : cpu->status;
	cpu->status = (val&N) ? cpu->status|N : cpu->status;
}

void DEX(cpu_t* cpu)
{
	cpu->register_x--;
	cpu->status = !cpu->register_x ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_x&N) ? cpu->status|N : cpu->status;
}

void DEY(cpu_t* cpu)
{
	cpu->register_y;
	cpu->status = !cpu->register_y ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_y&N) ? cpu->status|N : cpu->status;
}

void INC(cpu_t* cpu, uint16_t value)
{
	uint8_t val = mem_read(cpu->bus, value);
	val++;
	mem_write(cpu->bus, val, value);
	cpu->status = !val ? cpu->status|Z : cpu->status;
	cpu->status = (val&N) ? cpu->status|N : cpu->status;
}

void INX(cpu_t* cpu)
{
	cpu->register_x++;
	cpu->status = !cpu->register_x ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_x&N) ? cpu->status|N : cpu->status;
}

void INY(cpu_t* cpu)
{
	cpu->register_y++;
	cpu->status = !cpu->register_x ? cpu->status|Z : cpu->status;
	cpu->status = (cpu->register_x&N) ? cpu->status|N : cpu->status;
}

void JMP(cpu_t* cpu, uint16_t value)
{
	if (cpu->opcode.addr_mode == IND)
	{
		uint16_t addr = mem_read_u16(cpu->bus, value);
		value = addr;
	}
	cpu->program_counter = value;
}

void JSR(cpu_t* cpu, uint16_t value)
{
	uint16_t stck_addr = 0x100+(cpu->stack_pointer-1);
	mem_write_u16(cpu->bus, cpu->program_counter, stck_addr);
	cpu->stack_pointer -= 2;
	cpu->program_counter = value;
}

void RTS(cpu_t* cpu)
{
	uint16_t addr = 0x100+(cpu->stack_pointer+1);
	cpu->program_counter = mem_read_u16(cpu->bus, addr);
	cpu->stack_pointer += 2;
}

void RTI(cpu_t* cpu)
{
	uint16_t addr = 0x100+(cpu->stack_pointer+1);
	cpu->program_counter = mem_read_u16(cpu->bus, addr);
	cpu->stack_pointer += 2;
	addr = 0x100+cpu->stack_pointer;
	cpu->status = mem_read(cpu->bus, addr);
	cpu->stack_pointer++;
}